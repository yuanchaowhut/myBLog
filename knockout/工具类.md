# 4 工具类介绍 

## 4.1 ko.virtualElements
- 虚拟元素意义是什么？
1. The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
2. 作用类似于 React.Fragment
    
``` 
ko.virtualElements = {
    allowedBindings: {},
    childNodes: function(node) {},
    emptyNode: function(node) {},
    setDomNodeChildren: function(node, childNodes) {},
    prepend: function(containerNode, nodeToPrepend) {},
    insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {},
    firstChild: function(node) {},
    nextSibling: function(node) {},
    hasBindingValue: isStartComment,
    virtualNodeBindingValue: function(node) {},
    normaliseVirtualElementDomStructure: function(elementVerified) {}
};
```

### 4.1.1 hasBindingValue
作用：用来判断注释节点是否具有绑定关键字
``` 
var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";
var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;

function isStartComment(node) {
    return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
}
```
- commentNodesHaveTextProperty的作用：兼容ie9不能通过nodeValue获取注释节点的值
![avatar](../images/knockout/google-test_comment.png)
![avatar](../images/knockout/ie9_test_comment.png)

- 正向预查：(?:pattern) 和 (?=pattern)的异同点
    - 相同点：均不会获取匹配结果
    - 差异：是否消耗字符
        - (?:pattern) 消耗字符，下一字符匹配会从已匹配后的位置开始。 
        - (?=pattern) 不消耗字符，下一字符匹配会从预查之前的位置开始。 
这里其实没必要使用正向预查
  
  
### 4.1.2 normaliseVirtualElementDomStructure
>IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist <br/>
作用：在IE <= 8 或者 IE 9 怪异模式下，会忽略 </li>，因此需要做兼容处理即纠正dom树的结构 
- [案例参考](https://segmentfault.com/q/1010000004277806/a-1020000004279979)  
``` 
<ul id="ul1">
   <a href="#">li之前的a标签</a>
   <span>li之前的span标签</span>
   <li></li>
   <li></li>
   <span>li之前的span标签</span><!-- IE7下无法识别这个span标签，不知道为啥 -->
   <li></li>
   <span>li之后的span标签</span><!-- IE7下无法识别这个span标签，不知道为啥 -->
   <a href="#">li之后的a标签</a><!-- IE7下无法识别这个a标签，不知道为啥 -->
   2222
</ul>
```

- knockout-issue：https://github.com/knockout/knockout/issues/155
> IE7 will not allow anything but <li> as children of an <ul> 

## 4.2 ko.bindingProvider['instance']
// 单例模式
```
(function() {
    var defaultBindingAttributeName = "data-bind";
    ko.bindingProvider = function() {};
    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {},
        'getBindings': function(node, bindingContext) {},
        'getBindingAccessors': function(node, bindingContext) {},
        'getBindingsString': function(node, bindingContext) {},
        'parseBindingsString': function(bindingsString, bindingContext, node, options) {}
    });
    ko.bindingProvider['instance'] = new ko.bindingProvider(); 
    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {}
    function createBindingsStringEvaluator(bindingsString, options) {}
})(); 
```
### 4.2.1 nodeHasBindings
作用：用来判断节点是否具有绑定关键字
``` 
function(node) {
    switch (node.nodeType) {
        case 1: // Element
            return node.getAttribute(defaultBindingAttributeName) != null || ko.components['getComponentNameForNode'](node);
        case 8: // Comment node
            return ko.virtualElements.hasBindingValue(node);
        default: return false;
    }
}
```
- dom节点：<div data-bind=''></div>
- 注释：<!-- ko foreach: xxx -->  
### 4.2.3 getBindingAccessors
> 获取绑定访问器

```
'getBindingAccessors': function(node, bindingContext) {
    var bindingsString = this['getBindingsString'](node, bindingContext),
        parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
    return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
},
```
调用栈：
getBindingAccessors 
-> parseBindingsString （4.2.3.2）
-> createBindingsStringEvaluator （4.2.3.2）
-> ko.expressionRewriting.preProcessBindings （4.3.2 ）
-> ko.expressionRewriting.parseObjectLiteral（4.3.1 ）

#### 4.2.3.1 getBindingsString 获取绑定字符串两种情况
    - dom[nodeType=1]
    - dom[nodeType=8]即注释
    
#### 4.2.3.2 parseBindingsString
``` 
'parseBindingsString': function(bindingsString, bindingContext, node, options) {
    var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
    return bindingFunction(bindingContext, node);
    //...
}
``` 
 
- createBindingsStringEvaluatorViaCache -> createBindingsStringEvaluator -> createBindingsStringEvaluator
``` 
function createBindingsStringEvaluator(bindingsString, options) { 
    var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options), //见3.3.1
        functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
    var funInst = new Function("$context", "$element", functionBody);
    return funInst
    }
```
![avatar](../images/knockout/generate_ano-fun.png)

![avatar](../images/knockout/ano_resu.png) 


## 4.3 ko.expressionRewriting
``` 
ko.expressionRewriting = (function () { 
    return {
        bindingRewriteValidators: [],
        twoWayBindings: twoWayBindings,
        parseObjectLiteral: parseObjectLiteral,
        preProcessBindings: preProcessBindings,
        keyValueArrayContainsKey: function(keyValueArray, key) {}, 
        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {}
    };
})();
```
### 4.3.1 parseObjectLiteral：解析绑定字符串
1. 代码编译的第一个阶段通常是通过词法，语法的分析来判断代码本身是否存在词法或者语法上的问题，parseObjectLiteral的作用有点类似于这个作用；
2. 方法名也暗示了该方法的作用：合法的装换为对象；这里是需要讲绑定字符串转换为对象

![avatar](../images/knockout/parse_object_literal_test.png)

### 4.3.2 preProcessBindings

```
"'text':function(){return displayName },'style':function(){return { color:currentProfit() < 0 ?'red':'black'} },'css':function(){return { active:currentProfit() < 0} }"
```

## 4.4 ko.utils

### 4.4.1 fixUpContinuousNodeArray

### 4.4.2 setDomNodeChildrenFromArrayMapping
两处被调用
    - options
    - renderTemplateForEach （ko.bindingHandlers['template'].update）

该方法的过程还是很清晰的
    - 通过ko.utils.compareArrays方法对新老数组进行比对，从而得到新老数组中所有元素的状态（deleted，retained，added）
    - 遍历返回结果，将这些状态分类（新增的，移动的，删除的，保留的）
        - itemsForMoveCallbacks：存放被移动的数据   -> options['beforeMove']  
        - nodesToDelete：存放删除的节点             -> options['beforeRemove']
        - itemsToProcess：存放被保留下来的数据      -> 关键（只处理新增的数据）-> 4.4.2.1 
        - itemsForBeforeRemoveCallbacks             -> options['beforeRemove']
        - itemsForMoveCallbacks：存放被移动的数据   -> options['afterMove']
        - itemsForAfterAddCallbacks：存放添加的数据 -> options['afterAdd'] 

**注意**
- 如果你提供了 beforeRemove 选项
    - itemsToProcess会包含被删除的节点
    - 则该节点并不会被删除，只会清理该节点相关的缓存，框架把删除的逻辑交给了使用者，也就是说如果你不删除，则该节点不会被删除 
```
ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
    for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
        movedIndex = editScriptItem['moved'];
        switch (editScriptItem['status']) {
            case "deleted":
                //...
                if (options['beforeRemove']) { // 注意
                    itemsToProcess.push(mapData);  
                }
                //...
                break;  
                //...
        }
    }          
    //...
    ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);
    //...
}
```            

### 4.4.2.1 mapNodeAndRefreshWhenChanged
```
function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) { 
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];
 
            if (mappedNodes.length > 0) {
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                if (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
            }
 
            mappedNodes.length = 0;
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
    }
```

注意mappedNodes的更新，被disposeWhen引用着

参数解释
    - mapping（函数）：将数据映射为dom节点
    - callbackAfterAddingNodes（函数）：新增节点的处理，比如：ko绑定

### 4.4.3 compareArrays
>Levenshtein 距离，又称编辑距离

作用：由一个转换成另一个所需的最少编辑操作次数，（替换，插入，删除）

案例
```
ko.utils.compareArrays([1,2,3],[1,3,4,5,2],null)
```
![avatar](../images/knockout/compare_arrays.png)


## 4.4 replaceDomNodes

## 4.5 模板引擎
jqueryTmplTemplateEngine.js ， nativeTemplateEngine.js 这两个模板引擎都是继承于 templateEngine.js

- ko.nativeTemplateEngine
```
ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
```
- ko.jqueryTmplTemplateEngine
```
ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;

```

- 设置默认的模板引擎
```
ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

// 如果引用了jquery.tmpl
if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
    ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);
```

## 4.5.1 ko.templateEngine
- 这是一个基类，看到所有的方法都在原型对象上，作用很明了
```
ko.templateEngine = function () {throw new Error("Override renderTemplateSource");}; // 如果你没重写，呵呵，直接给你报错
ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {};
ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {};
ko.templateEngine.prototype['makeTemplateSource'] = function (template, templateDocument) {};
ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {};
ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {};
ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {};
```

#### 4.5.1.1 renderTemplate 
```
ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
};
```

#### 4.5.1.2 makeTemplateSource
```
ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};
```
看到templateDocument的作用了吗？用于查找模板

### 4.5.2 ko.nativeTemplateEngine  
- ko.nativeTemplateEngine 继承了 ko.templateEngine 

#### 4.5.2.1 renderTemplateSource
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText, templateDocument);
    }
};


## 4.6 ko.templateRewriting
### 4.6.1 ensureTemplateIsRewritten


## 4.7 ko.templateSources

## 4.8 ko.memoization
``` 
ko.memoization = (function () { 
    return {
        memoize: function (callback) {},
        unmemoize: function (memoId, callbackParams) {},
        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {},
        parseMemoText: function (memoText) {}
    };
})();
```
### 4.8.1 memoize
``` 
memoize: function (callback) {
    if (typeof callback != "function")
        throw new Error("You can only pass a function to ko.memoization.memoize()");
    var memoId = generateRandomId();
    memos[memoId] = callback;
    return "<!--[ko_memo:" + memoId + "]-->";
}
```
作用：通过生成一个注释元素，记录函数（显然该函数作为一个闭包存在）

### 4.8.2 unmemoize

### 4.8.3 unmemoizeDomNodeAndDescendants
